所有LoRa上行链路和下行链路消息均携带PHY有效载荷（**Payload**），以一个单字节MAC报头（**MHDR**）开始，随后是MAC有效负载（**MACPayload**）①，并以4个字节消息完整性码（**MIC**）结尾。

无线PHY层：

| Preamble | PHDR | PHDR\_CRC | PHYPayload | CRC |
| :---: | :---: | :---: | :---: | :---: |


PHYPayload：

| MHDR | MACPayload | MIC |
| :---: | :---: | :---: |


or

| MHDR | Join-Request or Rejoin-Request | MIC |
| :---: | :---: | :---: |


or

| MHDR | Join-Accept② |
| :---: | :---: |


MACPayload：

| FHDR | FPort | FRMPayload |
| :---: | :---: | :---: |


FHDR：

| DevAddr | FCtrl | FCnt | FOpts |
| :---: | :---: | :---: | :---: |


①第6章详细介绍了最大有效载荷大小。

②对于加入-接受帧，MIC字段使用有效载荷进行加密，而不是单独的字段。

# 4.1 MAC层（PHYPayload）

| Size（bytes） | 1 | 7.._M_ | 4 |
| :---: | :---: | :---: | :---: |
| PHYPayload | MHDR | MACPayload | MIC |

**MACPayload**字段的最大长度（_M_）是区域特定的，并在第6章中指定。

# 4.2 MAC报头（MHDR字段）

| Bit\# | 7..5 | 4..2 | 1..0 |
| :---: | :---: | :---: | :---: |
| MHDR bits | MType | RFU | Major |

MAC头指定了消息类型（**MType**），并根据哪个主要版本（**Major**）的LoRaWAN层规范的帧格式编码。

## 4.2.1 消息类型（MType位字段）

LoRaWAN区分8种不同的MAC消息类型：加入请求，重新加入请求，加入接受，未确认的数据上行/下行，以及确认的数据上行/下行和专有协议消息。

| MType | Description |
| :---: | :---: |
| 000 | Join-request |
| 001 | Join-accept |
| 010 | Unconfirmed Data Up |
| 011 | Unconfirmed Data Down |
| 100 | Confirmed Data Up |
| 101 | Confirmed Data Down |
| 110 | Rejoin-request |
| 111 | Proprietary |

### 4.2.1.1 加入请求和加入接受消息

加入请求，重新加入请求和加入接受消息由第6.2章中描述的OTA激活程序使用，并用于漫游目的。

### 4.2.1.2 数据消息

数据消息用于传输MAC命令和应用程序数据，可以在一条消息中结合在一起。**确认数据消息**必须由接收方确认，而**未确认数据消息**不需要确认①。**专有消息**可用于实现不能与标准消息互操作的非标准消息格式，但只能在对专有扩展具有共识的设备中使用。 当终端设备或网络服务器收到未知的专有信息时，它应该默默忽略它。

不同消息类型的消息完整性以不同的方式确保，并按照以下消息类型进行描述。

## 4.2.2 主要版本的数据信息（主要位字段）

| Major bits | Description |
| :---: | :---: |
| 00 | LoRaWAN R1 |
| 01..11 | RFU |

> 注意：主要版本规定了加入过程中交换的消息格式（见章节6.2）和MAC Payload的前四个字节，如第4章所述。对于每个主要版本，终端设备可以实现帧的不同次要版本格式。必须事先使用带外消息（例如，作为设备个性化信息的一部分）使网络服务器知道终端设备使用的次要版本。当设备或网络服务器收到一个携带未知或不支持的LoRaWAN版本的帧时，它应该默默忽略它。

# 4.3 数据消息的MAC有效载荷（MACPayload）

数据消息的MAC有效载荷包含一个帧头（**FHDR**），后面跟着一个可选端口字段（**FPort**）和一个可选帧有效载荷字段（**FRMPayload**）。一个具有有效FHDR，没有Fopts（FoptsLen = 0），没有Fport和没有FRMPayload的帧是有效帧。

## 4.3.1 帧头（FHDR）

**FHDR**包含终端设备（**DevAddr**）的短设备地址，1字节帧控制（**FCtrl**），2字节帧计数器（**FCnt**）以及最多15字节用于传输MAC命令的帧可选（**FOpts**）。如果存在，FOpts字段应使用如4.3.1.6节所述的NwkSEncKey进行加密。

| Size（bytes） | 4 | 1 | 2 | 0..15 |
| :---: | :---: | :---: | :---: | :---: |
| FHDR | DevAddr | FCtrl | FCnt | FOpts |

对于下行链路帧，帧头的FCtrl内容是：

| Bit\# | 7 | 6 | 5 | 4 | \[3..0\] |
| :---: | :---: | :---: | :---: | :---: | :---: |
| FCtrl bits | ADR | RFU | ACK | FPending | FOptsLen |

对于上行链路帧，帧头的FCtrl内容是：

| Bit\# | 7 | 6 | 5 | 4 | \[3..0\] |
| :---: | :---: | :---: | :---: | :---: | :---: |
| FCtrl bits | ADR | ADRACKReq | ACK | ClassB | FOptsLen |

### 4.3.1.1 帧头中的自适应数据速率控制（ADR，FCtrl中的ADRACKReq）

LoRa网络允许终端设备单独使用任何可能的数据速率和发射功率。LoRaWAN使用此功能来调整和优化静态终端设备的数据速率和发射功率。这被称为自适应数据速率（ADR），当启用时，网络将被优化以使用尽可能最快的数据速率。

自适应数据速率控制可能无法在无线信道衰减快速且持续变化时发生。当网络服务器无法控制设备的数据速率时，设备的应用层应该控制它。在这种情况下，建议使用各种不同的数据速率。应用层应该总是尽量减少网络条件下使用的总时间。

如果上行链路**ADR**位置1，网络将通过适当的MAC命令控制终端设备的数据速率和发射功率。如果未设置ADR位，则不管接收到的信号质量如何，网络都不会试图控制数据速率和终端设备的发射功率。网络仍然可以发送命令来改变信道掩码或帧重复参数。

当下行链路ADR位置1时，它会通知终端设备，网络服务器处于发送ADR命令的位置。设备可以设置/取消设置上行ADR位。

当下行链路ADR位未设置时，它向终端设备发信号通知由于无线信道的快速变化，网络暂时无法估计最佳数据速率。在这种情况下，该设备可以选择

* 取消设置ADR上行链路位，并根据其自身的策略控制上行链路数据速率。这应该是移动终端设备的典型策略。
* 忽略它（保持上行ADR位置1），并在没有ADR下行命令的情况下运用正常的数据速率衰减。这应该是固定终端设备的典型策略。

**ADR**位可以由终端设备或网络按需设置和取消设置。但是只要有可能，应该启用ADR方案以延长终端设备的电池寿命并最大限度地提高网络容量。

> 注意：即使是移动终端设备，大多数时间都是不动的。因此根据其移动状态，终端设备可以请求网络使用ADR上行链路位来优化其数据速率。

默认发射功率是考虑到设备功能和区域监管限制的器件允许的最大发射功率。通过LinkADRReq MAC命令，设备应使用此功率级别，直到网络要求较少。

如果网络对终端设备的数据速率进行了优化，使其数据速率高于其默认数据速率，或者TXPower的数据速率低于其默认TXPower，则它需要定期验证网络是否仍收到上行链路帧。每当上行链路帧计数器递增时（对于每个新的上行链路，重复传输都不会增加计数器），该设备递增ADR\_ACK\_CNT计数器。在ADR\_ACK\_LIMIT上行链路之后（ADR\_ACK\_CNT &gt;=  ADR\_ACK\_LIMIT）没有任何下行链路响应，它会设置ADR确认请求位（**ADRACKReq**）。网络需要在下一个ADR\_ACK\_DELAY帧内用下行链路帧进行响应，在上行链路帧之后的任何接收到的下行链路帧都会重置ADR\_ACK\_CNT计数器。下行ACK位不需要设置，因为在终端设备接收时隙期间的任何响应表明网关仍然接收到来自该设备的上行链路。如果在下一个ADR\_ACK\_DELAY上行链路内没有收到应答（即总共ADR\_ACK\_LIMIT + ADR\_ACK\_DELAY），则终端设备必须尝试重新获得连接，方法是在可能的情况下首先将发射功率提高到默认功率，然后切换到下一个较低的数据速率来提供更长的无线电范围。每次达到ADR\_ACK\_DELAY时，终端设备必须逐步降低其数据速率。一旦设备达到最低数据速率，它必须重新启用所有默认上行信道。

如果设备使用其默认数据速率和发射功率，则不应设置**ADRACKReq**，因为在这种情况下，不能采取任何措施来改善链路范围。

> 注意：不要求对ADR确认请求立即作出响应，为网络提供了灵活性，以便最佳地调度其下行链路。
>
> 注意：在上行链路传输中，如果ADR\_ACK\_CNT&gt; = ADR\_ACK\_LIMIT且当前数据速率大于设备定义的最小数据速率或其发送功率低于默认值，或当前信道掩码仅使用全部默认信道，**ADRACKReq**位置1。在其他条件下它会被清除。

_假设ADR\_ACK\_LIMIT和ADR\_ACK\_DELAY常量均等于32，下表提供了数据速率回退顺序的示例。_

| _ADR\_ACK\_CNT_ | _ADRACKReq bit_ | _Data Rate_ | _TX power_ | _Channel Mask_ |
| :---: | :---: | :---: | :---: | :---: |
| _0 to 63_ | _0_ | _SF11_ | _Max - 9dBm_ | _Single Channel enabled_ |
| _64 to 95_ | _1_ | _Keep_ | _Keep_ | _Keep_ |
| _96 to 127_ | _1_ | _Keep_ | _**Max**_ | _Keep_ |
| _128 to 159_ | _1_ | _**SF12**_ | _Max_ | _Keep_ |
| _&gt;= 160_ | _0_ | _SF12_ | _Max_ | _**All Channels enabled**_ |

### 4.3.1.2 消息确认位和确认过程（FCtrl中的ACK）

当接收到_确认的数据_消息时，接收方应以设置确认位（**ACK**）的数据帧进行响应。如果发送方是终端设备，则网络将尝试在发送操作之后使用终端设备打开的接收窗口之一发送确认。如果发送方是网关，则终端设备会自行决定传送确认（请参阅下面的注释）。

确认仅在响应收到最新消息时才会发送，并且不会重发。

> 注意：为了允许终端设备尽可能简单并且有尽可能少的状态，它可以在接收到需要确认的数据消息之后立即发送明确的（可能是空的）确认数据消息。或者终端设备可以推迟确认的传输，以将其与其下一个数据消息搭载。

### 4.3.1.3 重传过程

#### 下行链路帧：

下行链路“已确认”或“未确认”帧不得使用相同的帧计数器值重传。在“已确认”下行链路的情况下，如果未收到确认，应用程序服务器将收到通知，并可能决定重新发送新的“已确认”帧。

#### 上行链路帧：

上行链路“已确认”和“未确认”帧将发送“NbTrans”时间（见5.3），除非在传输之后接收到有效的下行链路。网络管理器可以使用“NbTrans”参数来控制节点上行链路的冗余度，以获得给定的服务质量。终端设备应该像往常一样在重复传输之间执行跳频，每次重复之前都应等待，直到接收窗口过期。重传之间的延迟由终端设备决定，并且对于每个终端设备可以不同。

如果接收到对应的下行链路确认帧，则设备应停止上行链路“确认”帧的任何进一步重传。

只要在RX1时隙窗口期间接收到有效的单播下行链路消息，B类和C类设备应停止上行链路“未确认”帧的任何进一步重传。

当在RX1或RX2时隙窗口期间接收到有效的下行链路消息时，A类设备应停止上行链路“未确认”帧的任何进一步重传。

如果网络接收到超过相同上行链路帧的NbTrans传输，则这可能是重放攻击或出现故障设备的迹象，因此网络将不处理额外的帧。

> 注意：检测到重放攻击的网络可以采取附加措施，诸如将NbTrans参数减少到1，或者丢弃上行链路帧，该帧已被早前相同帧所传输使用的一个信道接收到，或者通过一些其他未指定的机制。

### 4.3.1.4 帧等待位（在FCtrl中只有下行链路）

帧等待位（**FPending**）仅用于下行链路通信，表明网络有更多的待发送数据，因此通过发送另一个上行链路消息来请求终端设备尽快打开另一个接收窗口。

第19.3节描述了**FPending**位的确切用法。

### 4.3.1.5 帧计数器（FCnt）

每个终端设备都有三个帧计数器，用于跟踪上行至网络服务器（FCntUp）发送的数据帧数量，并从网络服务器向设备发送下行数据（FCntDown）。

在下行链路方向存在两个不同的帧计数器方案；单个计数器方案，其中当设备作为LoRaWAN1.0设备操作时，所有端口共享相同的下行链路帧计数器FCntDown；以及双计数器方案，当设备作为LoRaWAN1.1设备运行时，其中单独的NFCntDown用于在端口0和FPort字段丢失时进行的MAC通信，另一个AFCntDown用于所有其他端口。

在两个计数器方案中，NFCntDown由网络服务器管理，而AFCntDown由应用服务器管理。

> 注意：LoRaWAN v1.0及更早版本只支持一个FCntDown计数器（在所有端口间共享），网络服务器必须在LoRaWAN v1.1之前为设备支持该方案。

每当OTAA设备成功处理加入接受消息时，终端设备上的帧计数器（FCntUp）和网络侧的帧计数器（NFCntDown＆AFCntDown）将重置为0。

在制造时，ABP器件的帧计数器初始化为0。在ABP设备中，帧计数器在设备使用期限内不得重置。如果终端设备在其使用寿命期间遇到断电（例如电池更换），帧计数器应在此类事件期间应持续存在。

随后FCntUp随每个上行链路递增。NFCntDown随着在FPort 0或FPort字段丢失时的每个下行链路递增。AFCntDown随着每个下行链路在不同于0的端口上递增。在接收端，相应的计数器与接收到的值保持同步，只要接收到的值与当前的计数器值相比增加了，并且消息MIC字段与使用相应的网络会话密钥在本地计算的MIC值相匹配。如果多次传输确认或未确认的帧，FCnt不会递增（请参阅NbTrans参数）。网络服务器应该丢弃重发帧的应用负载，并且只将单个实例转发给应用服务器。

帧计数器为32位宽，**FCnt**字段对应于32位帧计数器的最低有效16位（即针对发送数据帧的上行链路的FCntUp和针对下行链路发送的数据帧的AFCntDown / NFCntDown）。

终端设备不得重复使用相同的FCntUp值和相同的应用或网络会话密钥，除了重传相同的已确认或未确认的帧。

终端设备永远不会处理同一个下行帧的任何重传。后续重传应被忽略而不被处理。

> 注意：这意味着一旦接收到一个下行链路确认帧，设备将只会确认，类似的，设备将在接收到设置了FPending位的帧后才会产生一个上行链路。
>
> 注意：由于**FCnt**字段仅携带32位帧计数器的最低有效16位，因此服务器必须根据流量观察推断帧计数器的16个最高有效位。

### 4.3.1.6 帧可选（FCtrl，FOpts中的FOptsLen）

**FCtrl**字节中的帧可选长度字段（**FOptsLen**）表示帧中包含的帧可选字段（**FOpts**）的实际长度。

**FOpts**传输MAC数据帧时顺带最大长度为15个字节的MAC命令；有关MAC命令的列表，请参阅第5章。

如果**FOptsLen**为0，则**FOpts**字段不存在。如果**FOptsLen**与0不同，即如果MAC命令出现在**FOpts字段**中，则不能使用端口0（**FPort**必须不存在或不同于0）。

MAC命令不能同时出现在有效载荷字段和帧可选字段中。如果发生这种情况，设备应忽略该帧。

如果帧头带有**FOpts**，则必须在计算消息完整性码（**MIC**）之前对**FOpts**进行加密。

所使用的加密方案基于IEEE 802.15.4/2006附件B \[IEEE802154\]中描述的使用密钥长度为128位的AES的通用算法。

使用的密钥**K**是上行链路和下行链路方向上的FOpts字段的NwkSEncKey字段。

加密的字段是：pld = **FOpts**

对于每条消息，算法定义一个单独的块_**A**_：

| Size（bytes） | 1 | 4 | 1 | 4 | 4 | 1 | 1 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| _A_ | 0x01 | 4 x 0x00 | Dir | DevAddr | FCntUp or NFCntDwn | 0x00 | 0x00 |

方向字段（**Dir**）对于上行链路帧是0，对于下行链路帧是1。块A被加密以获得块S：

_S_ = aes128\_encrypt\(K, _A_\)

**FOpts**的加密和解密是通过将（pld \| pad16）异或_S_后截断为第一个len（pld）字节来完成的。

### 4.3.1.7 B类

在上行链路中的将_Class B_位设置为1会向网络服务器发出信号，表示设备已切换到B类模式，并且现在已准备好接收调度的下行链路ping。有关B类规范，请参阅文件的B类部分。

## 4.3.2 端口字段（FPort）

如果帧有效载荷字段不为空，则必须存在端口字段。如果存在，则FPort值为0表示FRMPayload仅包含MAC命令，并且具有这样的FPort的任何接收到的帧应由LoRaWAN实现处理；有关MAC命令的列表，请参阅第5章。**FPort**值1..223（0x01..0xDF）是特定于应用程序的，并且具有这种FPort的任何接收到的帧都将由LoRaWAN实现提供给应用程序层。FPort值224专用于LoRaWAN MAC层测试协议。LoRaWAN实现应丢弃FPort值不在1..224范围内的应用层的任何传输请求。

> 注意：FPort值224的目的是提供专用的FPort，以便在最终版本的设备上OTA运行MAC一致性测试场景，而不必依赖实际方面的设备的特定测试版本。测试不应该与实时操作同时进行，但设备的MAC层实现应该与正常应用的完全一致。测试协议通常使用AppSKey进行加密。这确保了网络服务器不能在不涉及设备所有者的情况下启用设备的测试模式。如果测试在实时网络连接的设备上运行，则网络侧的测试应用程序得知AppSKey的方式超出了LoRaWAN规范的范围。如果测试在专用测试台（不是实时网络）上使用OTAA运行，则AppKey与测试台通信的方式（用于安全连接过程）也不在本规范的范围内。
>
> 在应用层运行的测试协议是在LoRaWAN规范之外定义的，因为它是一个应用层协议。

FPort值225..255（0xE1..0xFF）保留给将来的标准化应用程序扩展。

| Size（bytes） | 7..22 | 0..1 | 0.._N_ |
| :---: | :---: | :---: | :---: |
| MACPayload | FHDR | FPort | FRMPayload |

_N_是应用程​​序有效负载的字节数。N的有效范围是区域特定的，并在\[PHY\]中定义。

_N_必须等于或小于：

_N_ ≤ _M_ - 1 - \(length of **FHDR** in octets\)

其中_M_是最大MAC有效负载长度。

## 4.3.3 MAC帧有效负载加密（FRMPayload）

如果数据帧携带有效载荷，则必须在计算消息完整性代码（**MIC**）之前对**FRMPayload**进行加密。

所使用的加密方案基于IEEE 802.15.4/2006附件B \[IEEE802154\]中描述的使用密钥长度为128位的AES的通用算法。

使用的密钥_K_取决于数据消息的FPort：

| FPort | Direction | K |
| :---: | :---: | :---: |
| 0 | Uplink/downlink | NwkSEncKey |
| 1..255 | Uplink/downlink | AppSKey |

加密的字段是：

_pld_ = **FRMPayload**

对于每个数据消息，该算法定义一个_i_ = 1.._k_的块_Ai_的序列，其中_k_ = ceil\(len\(_pld\)_/ 16\)：

| Size（bytes） | 1 | 4 | 1 | 4 | 4 | 1 | 1 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| _Ai_ | 0x01 | 4 x 0x00 | Dir | DevAddr | FCntUp or NFCntDwn or AFCntDwn | 0x00 | _i_ |

方向字段（_Dir_）对于上行链路帧是0，对于下行链路帧是1。

块_Ai_被加密以获得块_Si_的序列_S_：

_Si_ = aes128\_encrypt\(K, _Ai_\) for _i_ = 1.._k_

_S_ = _S1_ \| _S2_ \| .. \| _Sk_

有效载荷的加密和解密是通过截断第一个len\(_pld_\)字节来完成的

\(_pld_ \| pad16\) xor S

# 4.4 消息完整性代码（MIC）

消息完整性代码（**MIC**）在消息中的所有字段上计算。

_msg_ = **MHDR** \| **FHDR** \| **FPort** \| **FRMPayload**

其中len\(_msg_\)表示消息的长度，以字节为单位。

## 4.4.1 下行链路帧

下行链路帧的**MIC**计算如下\[RFC4493\]：

_cmac_ = aes128\_cmac\(S**NwkSIntKey**, _B0_ \| _msg_\)

**MIC** = _cmac_\[0..3\]

由此块_B0_被定义如下：

| Size（bytes） | 1 | 2 | 2 | 1 | 4 | 4 | 1 | 1 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| _B0_ | 0x49 | ConfFCnt | 2 x 0x00 | Dir=0x01 | DevAddr | AFCntDwn ro NFCntDwn | 0x00 | len\(_msg_\) |

如果设备连接到LoRaWAN1.1网络服务器并且设置了下行链路帧的ACK位，表示该帧正在确认上行链路“已确认”帧，则ConfFCnt是“已确认”的帧计数器值模2 ^ 16“正在被确认的上行链路帧。在所有其他情况下，ConfFCnt = 0x0000。

## 4.4.2 上行链路帧

上行帧的**MIC**通过以下过程计算：

块_B0_被定义如下：

| Size（bytes） | 1 | 4 | 1 | 4 | 4 | 1 | 1 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| _B0_ | 0x49 | 0x0000 | Dir=0x00 | DevAddr | FCntUp | 0x00 | len\(_msg_\) |

块_B1_被定义如下：

| Size（bytes） | 1 | 2 | 1 | 1 | 1 | 4 | 4 | 1 | 1 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| _B1_ | 0x49 | ConfFCnt | TxDr | TxCh | Dir=0x00 | DevAddr | FCntUp | 0x00 | len\(_msg_\) |

其中：

* TxDr是用于上行链路传输的数据速率
* TxCh是用于传输的信道索引。
* 如果设置了上行链路帧的ACK位，意味着该帧正在确认下行链路“确认”帧，则ConfFCnt是正在确认的“确认”下行链路帧的模数2 ^ 16的帧计数器值。在所有其他情况下，ConfFCnt = 0x0000。

_cmacS_ = aes128\_cmac\(S**NwkSIntKey**, _B1_ \| _msg_\)

_cmacF_ = aes128\_cmac\(F**NwkSIntKey**, _B0_ \| _msg_\)

如果设备连接到LoRaWAN1.0网络服务器，则：

**MIC** = _cmacF_\[0..3\]

如果设备连接到LoRaWAN1.1网络服务器，则：

**MIC** = _cmacS_\[0..1\] \| _cmacF_\[0..1\]

